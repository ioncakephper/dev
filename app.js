const program = require('commander')
const { saveDocument, setDefaultExtension } = require("file-easy");
const hbsr = require('hbsr')
const yaml = require('yaml')
const fs = require('fs')
const {isArray, isString, isObject } = require('lodash')
const path = require('path')
/**
 * skelo check <outlineFilename>
 * 
 * skelo build [outline-filename] --destination docs --autoFolders
 */

program
    .name('skelo')
    .description('generate files for Docusaurus-powered documentation site')

program
    .command('check <outline-filename>')
    .description('check content of outline in the file')
    .action((outlineFilename) => {
        // console.log("ðŸš€ ~ file: app.js:13 ~ .action ~ outlineFilename", outlineFilename)
        // TODO: Develop code for checking outline structure.

    })

program
    .command('build <outlineFilename>', { isDefault: true })
    .description('build topic files and sidebar structure file for Docusaurus')
    .option('-d | --docs <path>', 'path to topic root folder', 'docs')
    .option('-s | --sidebar <sidebarFilename>', 'name of sidebar file to create',
        'sidebars.js')
    .option('--autoFolder', 'create folder for each category', false)
    .action((outlineFilename, options) => {
        outlineFilename = setDefaultExtension(outlineFilename, '.yaml')
        let sidebars = loadSidebars(outlineFilename)

        let sidebarsContent = buildSidebarsContent(sidebars, options);
        saveDocument(options.sidebar, hbsr.render(`/**
* Creating a sidebar enables you to:
- create an ordered group of docs
- render a sidebar for each doc of that group
- provide next/previous navigation

The sidebars can be generated from the filesystem, or explicitly defined here.

Create as many sidebars as you want.
*/

// @ts-check

/** @type {import('@docusaurus/plugin-content-docs').SidebarsConfig} */
module.exports = {{{content}}}`, { content: JSON.stringify(sidebarsContent, null, 4) }))
    })

// program.parse("node app build proposed-documentation-outline".split(/\s+/))
program.parse()

/**
 * Builds the sidebar content for the given sidebar.           
 * @param {Sidebar} sidebar - the sidebar object           
 * @param {SidebarOptions} options - the options for the sidebar           
 * @returns {SidebarContent} the sidebar content           
 */
function buildSidebarsContent(sidebars, options) {

    let documentationSidebars = {};
    sidebars.forEach(sidebar => {
        documentationSidebars[sidebar.label] = buildSidebarContent(sidebar, options)
    })
    return documentationSidebars;
}

/**
 * Builds the sidebar content for the given sidebar.           
 * @param {Sidebar} sidebar - the sidebar object           
 * @param {Options} options - the options object           
 * @returns {string[]} - the list of sidebar items           
 */
function buildSidebarContent(sidebar, options) {
    let items = sidebar.items
    let components = items.map((item) => {
        item = buildStandardItem(item)
        if (isCategory(item)) {
            let isAutoFolder = options.autoFolder || sidebar.autoFolder
            if (isAutoFolder) {
                let a = buildPath(sidebar)
                let b = isAutoFolder ? (item.folder || item.slug || item.label) : buildPath(item)
                item.folder = formattedFilePath(path.join(a, b))
            }
            let category = {
                label: item.label,
                type: 'category',
                items: buildSidebarContent(item, options)
            }
            let isAutoGenerated = item.autoGenerated || sidebar.autoGenerated || options.autoGenerated;
            if (isAutoGenerated) {
                category = {
                    ...category,
                    ...{
                        link: {
                            type: 'generated-index'
                        }
                    }
                }
                // let autoGeneratedPath = path.join(buildPath(sidebar), '_category_.json')

                // saveDocument(path.join(options.docs, autoGeneratedPath), JSON.stringify({
                //     'type': 'generated-index',

                // }, null, 4))
                // components.push(autoGeneratedPath)
            }

            return category
        }


        let itemPath = path.join(buildPath(sidebar), buildPath(item), buildFilename(buildItemSlug(item)))
        buildTopicDocument(path.join(options.docs, itemPath), item)
        return formattedFilePath(itemPath)
    })
    return components
}

/**
 * Builds a topic document for the given item.       
 * @param {string} targetFilename - the filename to save the document to.       
 * @param {Topic} item - the topic to build a document for.       
 * @returns None       
 */
function buildTopicDocument(targetFilename, item) {

    let data = {
        ...item, ...{
            title: item.title || item.label,
            sidebar_label: item.label,
            headings: buildHeadings(item.headings || [])
        }
    }
    let topicContent = hbsr.render(`---
title: {{{title}}}
sidebar_label: {{{sidebar_label}}}
{{#if tags}}
tags:
{{#each tags as |tag|}}
    - {{{tag}}}
{{/each}}
{{/if}}
---

# {{{title}}}
{{#if brief}}

{{{brief}}}
{{/if}}

{{#if headings}}
{{{headings}}}
{{/if}}

`, data)
    saveDocument(setDefaultExtension(targetFilename, '.md'), topicContent)
}

function buildHeadings(headings = [], level = 2) {
    return headings.map(heading => {
        return hbsr.render(`{{{prefix}}} {{{label}}}
{{#if brief}}

{{{brief}}}
{{/if}}

{{{headings}}}
`, {
            prefix: '#'.repeat(level),
            label: heading.label,
            brief: heading.brief || heading.excerpt,
            headings: buildHeadings(heading.items, level + 1)
        })
    }).join('')
}

/**
 * Builds a slug for the given item.       
 * @param {Item} item - the item to build a slug for.       
 * @returns {string} the slug for the given item.       
 */
function buildItemSlug(item) {
    return item.slug || item.label;
}

/**
 * Builds the path to the given item.           
 * @param {Item} item - the item to build the path for.           
 * @returns {string} the path to the given item.           
 */
function buildPath(item) {
    let itemPath = item.folder || ''
    itemPath = itemPath.trim().split('/').map(e => buildFilename(e)).join('/');
    return path.join(itemPath)
}

/**
 * Takes in a string and returns a string with all non-alphanumeric characters replaced with underscores.       
 * @param {string} source - the string to replace characters in       
 * @returns {string} - the string with all non-alphanumeric characters replaced with underscores       
 */
function buildFilename(source) {
    source = source.trim().toLowerCase();
    let replacableChars = /[^a-zA-Z0-9\_\-]+/;
    while (replacableChars.test(source)) {
        source = source.replace(replacableChars, '_')
    }
    return source
}

/**
 * Takes in a string of code and removes all the backslashes.       
 * @param {string} source - the code to format       
 * @returns None       
 */
function formattedFilePath(source = '') {
    source = source.trim();
    while (/\\/.test(source)) {
        source = source.replace(/\\/, '/')
    }
    return source;
}

/**
 * Checks if the given item is a category.           
 * @param {object} [item={items: []}] - the item to check           
 * @returns {boolean} - true if the item is a category, false otherwise           
 */
function isCategory(item = { items: [] }) {
    return item.items.length > 0
}

/**
 * Loads the sidebars from the given file.       
 * @param {string} filename - the name of the file to load the sidebars from.       
 * @returns {Array<SidebarItem>} - an array of SidebarItems.       
 */
function loadSidebars(filename) {
    let source = yaml.parse(fs.readFileSync(filename, 'utf-8'))['sidebars'];
    if (isString(source)) {
        return [buildStandardItem(source)]
    }
    if (isArray(source)) {
        return source.map(item => {
            return buildStandardItem(item)
        })
    }
}

/**
 * Takes in an item and returns a standard item object.           
 * @param {string | object} item - the item to convert to a standard item object.           
 * @returns {object} - the standard item object.           
 */
function buildStandardItem(item) {
    if (isString(item)) {
        item = { label: item }
    }
    if (isObject(item)) {
        if (!isStandard(item)) {
            item = buildItemFromObject(item)
        }
        item = { ...{ items: [] }, ...item }
    }
    if (Object.keys(item).includes('headings')) {
        item['headings'] = isString(item['headings'])
            ? buildStandardItem(item['headings'])
            : (isArray(item['headings'])
                ? item['headings'].map(item => buildStandardItem(item))
                : '')

        // item['headings'] = buildStandardItem(item['headings'])
    }
    return item;
}

/**
 * Takes in an object and returns a menu item object.           
 * @param {object} item - the object to build a menu item from.           
 * @returns {object} - the menu item object.           
 */
function buildItemFromObject(item) {
    let isValidObject = isObject(item) && Object.keys(item).length === 1;
    if (!isValidObject) {
        throw new Error('Expecting object with a single key')
    }
    let key = Object.keys(item)[0]
    let value = item[key]
    if (isArray(value)) {
        value = value.map(el => {
            return buildStandardItem(el);
        });
    } else {
        if (isObject(value)) {
            
            let localItem = { label: key }

            for (const tagName in value) {
                let el = value[tagName];
                // is a valid tagName format
                if (/^\@(.+)$/.test(tagName)) {
                    let tag = /^\@(.+)$/.exec(tagName)[1];
                    localItem[tag] = el;
                }
            }

            return buildStandardItem(localItem)
        }
    }

    if (isString(value)) {
        value = [value]
    }
    return {
        label: key,
        items: isArray(value) ? value.map(el => buildStandardItem(el)) : buildStandardItem(value)
    }

}

/**
 * Checks if the given item is a standard object.           
 * @param {object} item - the item to check           
 * @returns {boolean} - true if the item is a standard object, false otherwise           
 */
function isStandard(item = {}) {
    if (!isObject(item)) return false;
    return ['label'].some(key => Object.keys(item).includes(key))
}